## Read this in other languages:

- [English](./README_en.md)
- [中文](./README_cn.md)





## _Идентификация традиционной китайской медицины_

Традиционная китайская медицина, как незаменимый медицинский метод в мировой медицинской системе, в настоящее время все более известна и используется людьми. В этот период традиционная китайская медицина также пережила бурное развитие.Однако типы китайских лекарственных материалов многочисленны и сложны, а обычные люди имеют относительно ограниченные знания об идентификации китайских лекарственных материалов, что может привести к неблагоприятным последствиям, таким как неправильное использование.

-  Токсичность из-за неправильного использования.
- Потеря эффективности.
- лекарственное взаимодействие.
- Вводящая в заблуждение самодиагностика, угроза безопасности
- ✨финансовые потери✨


Эта модель призвана помочь людям, которые не понимают или не понимают традиционную китайскую медицину, легко определить виды традиционной китайской медицины, тем самым избежав вышеуказанной ситуации.

## Конкретная схема кода

> ├─ read.py #Чтение данных
> ├─ split.py #Классификация данных
> ├─ images  #Файлы изображений
> ├─ models #Модель
> ├─ main.py #пользовательский интерфейс（Эта часть не завершена на момент загрузки）
> ├─ test.py #Тестирование модели
> ├─ train.py #Модельное обучение

## read.py
Основная функция этого кода — анализ количества изображений в каждой подпапке указанной папки и использование библиотеки Matplotlib для создания горизонтальной гистограммы для визуального отображения распределения количества изображений в каждой подпапке. Основные шаги включают в себя:

Подсчитайте количество изображений в каждой подпапке с помощью функции read_flower_data.
Используйте функцию show_bar, чтобы создать гистограмму, которая отображает имена подпапок по оси Y и соответствующее количество изображений по оси X.
Основная цель этого кода — помочь пользователям понять данные изображения в определенной папке, чтобы лучше понять распределение количества изображений в различных подпапках.

Ниже приведен вывод изображения：
![Example Image](https://github.com/whossssssss/ML/blob/google-colab/myplot.png)

## split.py
Основная функция этого кода — разделить набор данных изображения в папке исходных данных на обучающий набор, набор проверки и тестовый набор и скопировать их в разные целевые папки.

функция data_set_split:
- src_data_folder: папка исходных данных, содержащая данные изображения каждой категории.
- target_data_folder: целевая папка, используемая для хранения разделенных наборов данных.
- train_scale, val_scale и test_scale: соотношение обучающего набора, набора проверки и набора тестов, по умолчанию — 0,8, 0,0 и 0,2.

Операции внутри функции:
- Сначала он извлекает все категории в папке исходных данных (категории существуют в виде папок).
- Затем в целевой папке создаются три подпапки: train, val и test для хранения данных изображения обучающего набора, проверочного набора и тестового набора соответственно.
- Далее он перебирает каждую категорию:

> Для каждой категории он меняет порядок данных изображения для этой категории, чтобы обеспечить случайность данных.
Скопируйте изображения в папку обучающего набора, проверочного набора или тестового набора в соответствии с заданным соотношением. Каждое изображение присваивается одному из поднаборов данных в случайном порядке.
Наконец, функция выводит разбивку по каждой категории, включая путь к папке и количество изображений, содержащихся в каждом поднаборе данных.

## train.py
В этом коде выбор модели осуществляется посредством трансферного обучения с использованием предварительно обученной модели MobileNetV2 в качестве базовой модели. Вот основная информация о модели:
- Используемая предварительно обученная модель: MobileNetV2.
- Зафиксируйте базовые веса: base_model.trainable = False, что означает, что веса предварительно обученной модели MobileNetV2 замораживаются и точная настройка не выполняется.
- Пользовательские слои: пользовательский слой глобального среднего пула и выходной слой, добавленные поверх модели MobileNetV2.

Ниже приведен графический вывод обученной модели:
![Example Image](https://github.com/whossssssss/ML/blob/google-colab/train_1.png)
![Example Image](https://github.com/whossssssss/ML/blob/google-colab/train_2.png)

В будущих планах улучшения модели мы будем использовать собственную модель сверточной нейронной сети (CNN), но на момент загрузки она еще не реализована.

## test.py
Загрузите обученную модель и протестируйте ее, чтобы оценить производительность модели на тестовых данных. Результаты испытаний включают потери и точность, которые измеряют производительность модели на новых, ранее неизвестных данных.

Ниже приведены выходные данные тестового набора:
```sh
Found 176 files belonging to 5 classes.
Using 35 files for validation.
Model: "sequential"
_________________________________________________________________
 Layer (type)                Output Shape              Param #   
=================================================================
 rescaling (Rescaling)       (None, 224, 224, 3)       0         
                                                                 
 mobilenetv2_1.00_224 (Func  (None, 7, 7, 1280)        2257984   
 tional)                                                         
                                                                 
 global_average_pooling2d (  (None, 1280)              0         
 GlobalAveragePooling2D)                                         
                                                                 
 dense (Dense)               (None, 5)                 6405      
                                                                 
=================================================================
Total params: 2264389 (8.64 MB)
Trainable params: 6405 (25.02 KB)
Non-trainable params: 2257984 (8.61 MB)
_________________________________________________________________
9/9 [==============================] - 2s 72ms/step - loss: 0.0044 - accuracy: 1.0000
Test accuracy : 1.0
```
#### UI пользовательский интерфейс

Это начальный интерфейс, система предлагает пользователю выбрать картинку и сделать прогнозы.
![Example Image](https://github.com/whossssssss/ML/blob/google-colab/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-12%20191311.png)
Когда в модель передается изображение (распространенные форматы изображений, такие как jpg, jpeg, png и т. д.), интерфейс делает прогнозы относительно изображения.
![Example Image](https://github.com/whossssssss/ML/blob/google-colab/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-12%20191324.png)
![Example Image](https://github.com/whossssssss/ML/blob/google-colab/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-12%20191331.png)
![Example Image](https://github.com/whossssssss/ML/blob/google-colab/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-12%20191800.png)
![Example Image](https://github.com/whossssssss/ML/blob/google-colab/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-12%20191807.png)
Ниже приведен анимированный дисплей:
![Example Image](https://github.com/whossssssss/ML/blob/google-colab/2378fe0a-ae7c-4874-beed-58958a718585.gif)


Мы также будем стремиться изучить больше функций, таких как возможность выводить лечебные эффекты традиционной китайской медицины одновременно с выводом, а также обучать и внедрять робота вопросов и ответов традиционной китайской медицины (то есть он может давать соответствующие диагностика традиционной китайской медицины на основе симптомов, предоставленных пользователем, и т. д.)

Последующий контент будет постоянно обновляться...
